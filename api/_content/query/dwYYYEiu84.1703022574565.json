{"_path":"/plugins/limit","_dir":"plugins","_draft":false,"_partial":false,"_locale":"","title":"limit - Limits plugin for Haraka","description":"Haraka limit plugin - Limits the number of messages per connection","navigation":{"title":"limit"},"body":{"type":"root","children":[{"type":"element","tag":"h1","props":{"id":"limit-plugin"},"children":[{"type":"text","value":"limit plugin"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Apply several types of limits to SMTP connections."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Each limit type has a max value that can be defined in limit.ini. The default is empty / disabled until a value has been set."}]},{"type":"element","tag":"h2","props":{"id":"concurrency"},"children":[{"type":"text","value":"concurrency"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"When "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"[concurrency]max"}]},{"type":"text","value":" is defined, it limits the maximum number of simultaneous connections per IP address. Connection attempts in excess of the limit are delayed for "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"disconnect_delay"}]},{"type":"text","value":" seconds (default: 3) before being disconnected."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This works best in conjunction with a history / reputation database, so that\none can assign very low concurrency (1) to bad or unknown senders and higher\nlimits for reputable mail servers."}]},{"type":"element","tag":"h3","props":{"id":"history"},"children":[{"type":"text","value":"History"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"History: when enabled, the "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"history"}]},{"type":"text","value":" setting is the name of a plugin that stores IP history / reputation results. The result store must have a positive value for good connections and negative integers for poor / undesirable connections. Karma is one such plugin."}]},{"type":"element","tag":"h2","props":{"id":"recipients"},"children":[{"type":"text","value":"recipients"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"When "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"[recipients]max"}]},{"type":"text","value":" is defined, each connection is limited to that number of recipients. The limit is imposed against "},{"type":"element","tag":"strong","props":{},"children":[{"type":"text","value":"all"}]},{"type":"text","value":" recipient attempts. Attempts in excess of the limit are issued a temporary failure."}]},{"type":"element","tag":"h2","props":{"id":"unrecognized_commands"},"children":[{"type":"text","value":"unrecognized_commands"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"When "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"[unrecognized_commands]max"}]},{"type":"text","value":" is set, a connection that exceeeds the limit is disconnected."}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Unrecognized commands are normally SMTP verbs invalidly issued by the client.\nExamples:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"issuing AUTH when we didn't advertise AUTH extension"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"issuing STARTTLS when we didn't advertise STARTTLS"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"invalid SMTP verbs"}]}]},{"type":"element","tag":"h3","props":{"id":"limitations"},"children":[{"type":"text","value":"Limitations"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"The unrecognized_command hook is used by the "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"tls"}]},{"type":"text","value":" and "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"auth"}]},{"type":"text","value":" plugins, so\nrunning this plugin before those would result in valid operations getting\ncounted against that connections limits. The solution is simple: list\n"},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"limit"}]},{"type":"text","value":" in config/plugins after those."}]},{"type":"element","tag":"h2","props":{"id":"errors"},"children":[{"type":"text","value":"errors"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"When "},{"type":"element","tag":"code","props":{"className":""},"children":[{"type":"text","value":"[errors]max"}]},{"type":"text","value":" is set, a connection that exceeeds the limit is disconnected. Errors that count against this limit include:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"issuing commands out of turn (MAIL before EHLO, RCPT before MAIL, etc)"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"attempting MAIL on port 465/587 without AUTH"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"MAIL or RCPT addresses that fail to parse"}]}]},{"type":"element","tag":"h1","props":{"id":"error-handling"},"children":[{"type":"text","value":"Error Handling"}]},{"type":"element","tag":"h2","props":{"id":"too-high-counters"},"children":[{"type":"text","value":"Too high counters"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"If the NoSQL store is Redis and Haraka is restarted or crashes while active\nconnections are open, the concurrency counters might be inflated. This is\nhandled by the "},{"type":"element","tag":"span","props":{},"children":[{"type":"text","value":"concurrency"}]},{"type":"text","value":"reset setting (default: 10m), which:"}]},{"type":"element","tag":"ul","props":{},"children":[{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"ssc: sets collection expiration time"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"redis: empties the concurrency hash"}]},{"type":"element","tag":"li","props":{},"children":[{"type":"text","value":"RAM: empties the in-memory hash of all keys"}]}]},{"type":"element","tag":"h2","props":{"id":"too-low-counters"},"children":[{"type":"text","value":"Too low counters"}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"Because the redis and RAM objects are emptied periodically, connections that\nare open while the collections are emptied will be too low. When\nthat happens, log messages like these might be emitted:"}]},{"type":"element","tag":"pre","props":{"code":"resetting 0 to 1\nresetting -1 to 1\n"},"children":[{"type":"element","tag":"code","props":{"__ignoreMap":""},"children":[{"type":"text","value":"resetting 0 to 1\nresetting -1 to 1\n"}]}]},{"type":"element","tag":"p","props":{},"children":[{"type":"text","value":"This is a harmless error condition that is repaired automatically."}]}],"toc":{"title":"","searchDepth":2,"depth":2,"links":[{"id":"concurrency","depth":2,"text":"concurrency","children":[{"id":"history","depth":3,"text":"History"}]},{"id":"recipients","depth":2,"text":"recipients"},{"id":"unrecognized_commands","depth":2,"text":"unrecognized_commands","children":[{"id":"limitations","depth":3,"text":"Limitations"}]},{"id":"errors","depth":2,"text":"errors"},{"id":"too-high-counters","depth":2,"text":"Too high counters"},{"id":"too-low-counters","depth":2,"text":"Too low counters"}]}},"_type":"markdown","_id":"content:8.plugins:limit.md","_source":"content","_file":"8.plugins/limit.md","_extension":"md"}